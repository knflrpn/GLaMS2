<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SwiCC Visual Controller Display</title>
	<style>
		body {
			font-family: 'Courier New', monospace;
			background: #1a1a1a;
			color: #ffffff;
			padding: 20px;
			margin: 0;
			overflow-x: auto;
		}

		.container {
			max-width: 1200px;
			margin: 0 auto;
			background: #2d2d2d;
			border-radius: 10px;
			padding: 20px;
			border: 1px solid #444;
		}

		.header {
			text-align: center;
			margin-bottom: 20px;
			padding-bottom: 15px;
			border-bottom: 1px solid #444;
		}

		.status {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 10px;
			margin-bottom: 15px;
		}

		.status-dot {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #ff4444;
			transition: background 0.3s ease;
		}

		.status-dot.connected {
			background: #44ff44;
		}

		.info-line {
			margin: 5px 0;
			color: #aaa;
		}

		.controller-container {
			display: flex;
			justify-content: center;
			align-items: center;
			margin: 20px 0;
			position: relative;
		}

		.controller-visual {
			position: relative;
			display: inline-block;
		}

		.controller-image {
			max-width: 800px;
			width: 100%;
			height: auto;
			display: block;
		}

		.button-highlight {
			position: absolute;
			border-radius: 50%;
			pointer-events: none;
			transition: all 0.1s ease;
			opacity: 0;
			transform: scale(0.8);
		}

		.button-highlight.active {
			opacity: 1;
			transform: scale(1);
		}

		.button-highlight.outer {
			border: 3px solid #ff4444;
			background: rgba(255, 68, 68, 0.2);
		}

		.button-highlight.inner {
			border: 2px solid #ffff44;
			background: rgba(255, 255, 68, 0.3);
		}

		.dpad-highlight {
			position: absolute;
			pointer-events: none;
			transition: all 0.1s ease;
			opacity: 0;
			transform: scale(0.8);
			border: 2px solid #44ff44;
			background: rgba(68, 255, 68, 0.2);
		}

		.dpad-highlight.active {
			opacity: 1;
			transform: scale(1);
		}

		.thumbstick {
			position: absolute;
			width: 60px;
			height: 60px;
			transition: all 0.05s ease;
			pointer-events: none;
		}

		.thumbstick img {
			width: 100%;
			height: 100%;
		}

		.trigger-display {
			position: absolute;
			display: flex;
			gap: 20px;
			top: -80px;
			left: 50%;
			transform: translateX(-50%);
		}

		.trigger {
			position: relative;
			opacity: 0.7;
			transition: all 0.1s ease;
		}

		.trigger.active {
			opacity: 1;
			transform: scale(1.1);
		}

		.trigger img {
			width: 80px;
			height: auto;
		}

		.trigger-value {
			position: absolute;
			bottom: -20px;
			left: 50%;
			transform: translateX(-50%);
			color: #4fd1c7;
			font-size: 12px;
			font-weight: bold;
		}

		.no-data {
			text-align: center;
			color: #666;
			font-style: italic;
			padding: 40px;
		}

		.data-section {
			margin: 20px 0;
			padding: 15px;
			background: #1a1a1a;
			border-radius: 8px;
			border-left: 4px solid #4fd1c7;
		}

		.data-section h3 {
			color: #4fd1c7;
			margin-bottom: 10px;
			font-size: 1.2rem;
		}

		.data-content {
			white-space: pre-wrap;
			font-size: 0.9rem;
			line-height: 1.4;
			color: #ccc;
		}
	</style>
</head>

<body>
	<div class="container">
		<div class="header">
			<h1>ðŸŽ® SwiCC Visual Controller Display</h1>
			<div class="status">
				<div class="status-dot" id="statusDot"></div>
				<span id="statusText">Waiting for connection...</span>
			</div>
			<div class="info-line">Channel: <span id="channelName">swicc-controller</span></div>
			<div class="info-line">Rate: <span id="messageRate">0</span> msg/s | Sources: <span id="activeSources">0</span></div>
			<div class="info-line">Last Update: <span id="lastUpdate">Never</span></div>
		</div>

		<div class="controller-container">
			<div class="controller-visual">
				<!-- Trigger display -->
				<div class="trigger-display">
					<div class="trigger" id="triggerZL">
						<img src="./images/ZL.png" alt="ZL" onerror="this.style.display='none'">
						<div class="trigger-value" id="triggerZLValue">0.00</div>
					</div>
					<div class="trigger" id="triggerZR">
						<img src="./images/ZR.png" alt="ZR" onerror="this.style.display='none'">
						<div class="trigger-value" id="triggerZRValue">0.00</div>
					</div>
				</div>

				<!-- Main controller image -->
				<img src="./images/controller.png" alt="Controller" class="controller-image" id="controllerImage" onerror="this.style.display='none'">

				<!-- Button highlights (will be positioned dynamically) -->
				<div class="button-highlight outer" id="buttonA"></div>
				<div class="button-highlight inner" id="buttonAInner"></div>
				<div class="button-highlight outer" id="buttonB"></div>
				<div class="button-highlight inner" id="buttonBInner"></div>
				<div class="button-highlight outer" id="buttonX"></div>
				<div class="button-highlight inner" id="buttonXInner"></div>
				<div class="button-highlight outer" id="buttonY"></div>
				<div class="button-highlight inner" id="buttonYInner"></div>
				<div class="button-highlight outer" id="buttonL"></div>
				<div class="button-highlight outer" id="buttonR"></div>
				<div class="button-highlight outer" id="buttonPlus"></div>
				<div class="button-highlight outer" id="buttonMinus"></div>
				<div class="button-highlight outer" id="buttonHome"></div>
				<div class="button-highlight outer" id="buttonCapture"></div>

				<!-- D-pad highlights -->
				<div class="dpad-highlight" id="dpadUp"></div>
				<div class="dpad-highlight" id="dpadDown"></div>
				<div class="dpad-highlight" id="dpadLeft"></div>
				<div class="dpad-highlight" id="dpadRight"></div>

				<!-- Thumbsticks -->
				<div class="thumbstick" id="leftThumbstick">
					<img src="./images/thumbstick.png" alt="Left Thumbstick" onerror="this.style.display='none'">
				</div>
				<div class="thumbstick" id="rightThumbstick">
					<img src="./images/thumbstick.png" alt="Right Thumbstick" onerror="this.style.display='none'">
				</div>
			</div>
		</div>

		<div id="dataDisplay">
			<div class="no-data">No controller data received yet</div>
		</div>
	</div>

	<script>
		/**
		 * ControllerDisplay class - simplified version for this HTML file
		 */
		class ControllerDisplay {
			constructor(channelName = 'swicc-controller') {
				this.channelName = channelName;
				this.channel = new BroadcastChannel(channelName);
				this.isConnected = false;
				this.lastUpdate = 0;
				this.messageCount = 0;
				this.activeSources = new Set();
				this.currentData = {};

				this.setupEventListeners();
				this.startMonitoring();

				console.log(`Controller display initialized on channel: ${channelName}`);
			}

			setupEventListeners() {
				this.channel.onmessage = (event) => {
					this.handleMessage(event.data);
				};
			}

			handleMessage(message) {
				const now = Date.now();
				this.messageCount++;

				if (message.type === 'controller-state') {
					this.handleControllerState(message);
					this.updateConnectionStatus(true);
					this.lastUpdate = now;
				} else if (message.type === 'control') {
					this.handleControlMessage(message);
				}
			}

			handleControllerState(message) {
				this.currentData[message.dataType] = message.state;
				this.activeSources.add(message.dataType);

				if (typeof this.onStateUpdate === 'function') {
					this.onStateUpdate(message.dataType, message.state, this.currentData);
				}
			}

			handleControlMessage(message) {
				const { subType, dataType } = message;

				switch (subType) {
					case 'manipulator-detached':
						this.activeSources.delete(dataType);
						delete this.currentData[dataType];
						break;
				}

				if (typeof this.onControlMessage === 'function') {
					this.onControlMessage(subType, dataType);
				}
			}

			updateConnectionStatus(connected) {
				this.isConnected = connected;

				if (typeof this.onConnectionChange === 'function') {
					this.onConnectionChange(connected);
				}
			}

			startMonitoring() {
				setInterval(() => {
					const timeSinceLastUpdate = Date.now() - this.lastUpdate;

					if (timeSinceLastUpdate > 3000 && this.isConnected) {
						this.updateConnectionStatus(false);
						this.activeSources.clear();
					}

					if (typeof this.onStatsUpdate === 'function') {
						this.onStatsUpdate({
							messageRate: this.messageCount,
							timeSinceLastUpdate,
							activeSources: Array.from(this.activeSources),
							isConnected: this.isConnected
						});
					}

					this.messageCount = 0;
				}, 1000);
			}
		}

		// Initialize the controller display
		const display = new ControllerDisplay();

		// Get DOM elements
		const statusDot = document.getElementById('statusDot');
		const statusText = document.getElementById('statusText');
		const channelName = document.getElementById('channelName');
		const messageRate = document.getElementById('messageRate');
		const activeSources = document.getElementById('activeSources');
		const lastUpdate = document.getElementById('lastUpdate');
		const dataDisplay = document.getElementById('dataDisplay');
		const controllerImage = document.getElementById('controllerImage');

		// Button position mappings (relative to controller image)
		const buttonPositions = {
			A: { x: 0.75, y: 0.55 },
			B: { x: 0.78, y: 0.48 },
			X: { x: 0.72, y: 0.48 },
			Y: { x: 0.75, y: 0.41 },
			L: { x: 0.15, y: 0.15 },
			R: { x: 0.85, y: 0.15 },
			Plus: { x: 0.65, y: 0.3 },
			Minus: { x: 0.35, y: 0.3 },
			Home: { x: 0.6, y: 0.7 },
			Capture: { x: 0.4, y: 0.7 }
		};

		// D-pad positions
		const dpadPositions = {
			Up: { x: 0.25, y: 0.42, width: 0.04, height: 0.06 },
			Down: { x: 0.25, y: 0.56, width: 0.04, height: 0.06 },
			Left: { x: 0.18, y: 0.49, width: 0.06, height: 0.04 },
			Right: { x: 0.32, y: 0.49, width: 0.06, height: 0.04 }
		};

		// Thumbstick base positions
		const thumbstickPositions = {
			left: { x: 0.35, y: 0.65 },
			right: { x: 0.65, y: 0.65 }
		};

		// Initialize button positions
		function initializeButtonPositions() {
			const rect = controllerImage.getBoundingClientRect();
			const containerRect = controllerImage.parentElement.getBoundingClientRect();
			
			const offsetX = rect.left - containerRect.left;
			const offsetY = rect.top - containerRect.top;
			const width = rect.width;
			const height = rect.height;

			// Position face buttons
			Object.entries(buttonPositions).forEach(([button, pos]) => {
				const element = document.getElementById(`button${button}`);
				const innerElement = document.getElementById(`button${button}Inner`);
				
				if (element) {
					const size = 40;
					element.style.left = `${offsetX + pos.x * width - size/2}px`;
					element.style.top = `${offsetY + pos.y * height - size/2}px`;
					element.style.width = `${size}px`;
					element.style.height = `${size}px`;
				}
				
				if (innerElement) {
					const size = 25;
					innerElement.style.left = `${offsetX + pos.x * width - size/2}px`;
					innerElement.style.top = `${offsetY + pos.y * height - size/2}px`;
					innerElement.style.width = `${size}px`;
					innerElement.style.height = `${size}px`;
				}
			});

			// Position D-pad
			Object.entries(dpadPositions).forEach(([direction, pos]) => {
				const element = document.getElementById(`dpad${direction}`);
				if (element) {
					element.style.left = `${offsetX + pos.x * width - (pos.width * width)/2}px`;
					element.style.top = `${offsetY + pos.y * height - (pos.height * height)/2}px`;
					element.style.width = `${pos.width * width}px`;
					element.style.height = `${pos.height * height}px`;
				}
			});

			// Position thumbsticks
			const leftThumbstick = document.getElementById('leftThumbstick');
			const rightThumbstick = document.getElementById('rightThumbstick');
			
			if (leftThumbstick) {
				leftThumbstick.style.left = `${offsetX + thumbstickPositions.left.x * width - 30}px`;
				leftThumbstick.style.top = `${offsetY + thumbstickPositions.left.y * height - 30}px`;
			}
			
			if (rightThumbstick) {
				rightThumbstick.style.left = `${offsetX + thumbstickPositions.right.x * width - 30}px`;
				rightThumbstick.style.top = `${offsetY + thumbstickPositions.right.y * height - 30}px`;
			}
		}

		// Initialize positions when image loads
		controllerImage.onload = initializeButtonPositions;
		window.addEventListener('resize', initializeButtonPositions);

		// Set up event handlers
		display.onStateUpdate = (dataType, state, allStates) => {
			updateVisualDisplay(allStates);
			updateDataDisplay(allStates);
		};

		display.onConnectionChange = (connected) => {
			statusDot.classList.toggle('connected', connected);
			statusText.textContent = connected ? 'Connected' : 'Disconnected';

			if (!connected) {
				dataDisplay.innerHTML = '<div class="no-data">Connection lost</div>';
				clearVisualHighlights();
			}
		};

		display.onStatsUpdate = (stats) => {
			messageRate.textContent = stats.messageRate;
			activeSources.textContent = stats.activeSources.length;

			if (stats.timeSinceLastUpdate < 1000) {
				lastUpdate.textContent = 'Just now';
			} else if (stats.timeSinceLastUpdate < 60000) {
				lastUpdate.textContent = `${Math.floor(stats.timeSinceLastUpdate / 1000)}s ago`;
			} else {
				lastUpdate.textContent = 'Over a minute ago';
			}
		};

		function updateVisualDisplay(allStates) {
			Object.values(allStates).forEach(state => {
				// Update digital buttons
				if (state.digital) {
					Object.entries(state.digital).forEach(([button, pressed]) => {
						const element = document.getElementById(`button${button}`);
						const innerElement = document.getElementById(`button${button}Inner`);
						
						if (element) {
							element.classList.toggle('active', pressed);
						}
						if (innerElement) {
							innerElement.classList.toggle('active', pressed);
						}

						// Handle D-pad
						if (button.startsWith('Dpad')) {
							const direction = button.replace('Dpad', '');
							const dpadElement = document.getElementById(`dpad${direction}`);
							if (dpadElement) {
								dpadElement.classList.toggle('active', pressed);
							}
						}
					});
				}

				// Update analog inputs
				if (state.analog) {
					// Thumbsticks
					if (state.analog.LStickX !== undefined || state.analog.LStickY !== undefined) {
						updateThumbstick('left', state.analog.LStickX || 0, state.analog.LStickY || 0);
					}
					if (state.analog.RStickX !== undefined || state.analog.RStickY !== undefined) {
						updateThumbstick('right', state.analog.RStickX || 0, state.analog.RStickY || 0);
					}

					// Triggers
					if (state.analog.ZL !== undefined) {
						updateTrigger('ZL', state.analog.ZL);
					}
					if (state.analog.ZR !== undefined) {
						updateTrigger('ZR', state.analog.ZR);
					}
				}
			});
		}

		function updateThumbstick(side, x, y) {
			const thumbstick = document.getElementById(`${side}Thumbstick`);
			if (!thumbstick) return;

			const rect = controllerImage.getBoundingClientRect();
			const containerRect = controllerImage.parentElement.getBoundingClientRect();
			
			const offsetX = rect.left - containerRect.left;
			const offsetY = rect.top - containerRect.top;
			const width = rect.width;
			const height = rect.height;

			const basePos = thumbstickPositions[side];
			const maxOffset = 15; // Maximum pixel offset

			const newX = offsetX + basePos.x * width - 30 + (x * maxOffset);
			const newY = offsetY + basePos.y * height - 30 + (y * maxOffset);

			thumbstick.style.left = `${newX}px`;
			thumbstick.style.top = `${newY}px`;
		}

		function updateTrigger(trigger, value) {
			const element = document.getElementById(`trigger${trigger}`);
			const valueElement = document.getElementById(`trigger${trigger}Value`);
			
			if (element) {
				element.classList.toggle('active', value > 0.1);
			}
			if (valueElement) {
				valueElement.textContent = value.toFixed(2);
			}
		}

		function clearVisualHighlights() {
			// Clear all button highlights
			document.querySelectorAll('.button-highlight, .dpad-highlight').forEach(el => {
				el.classList.remove('active');
			});

			// Reset thumbsticks
			updateThumbstick('left', 0, 0);
			updateThumbstick('right', 0, 0);

			// Reset triggers
			updateTrigger('ZL', 0);
			updateTrigger('ZR', 0);
		}

		function updateDataDisplay(allStates) {
			const stateKeys = Object.keys(allStates);

			if (stateKeys.length === 0) {
				dataDisplay.innerHTML = '<div class="no-data">No data available</div>';
				return;
			}

			let html = '';

			stateKeys.forEach(dataType => {
				const state = allStates[dataType];
				html += `
					<div class="data-section">
						<h3>${dataType.toUpperCase()}</h3>
						<div class="data-content">${formatState(state)}</div>
					</div>
				`;
			});

			dataDisplay.innerHTML = html;
		}

		function formatState(state) {
			let output = '';

			// Digital buttons
			if (state.digital && Object.keys(state.digital).length > 0) {
				output += 'DIGITAL BUTTONS:\n';
				for (const [button, pressed] of Object.entries(state.digital)) {
					if (pressed) {
						output += `  ${button}: ${pressed ? 'PRESSED' : 'released'}\n`;
					}
				}
				output += '\n';
			}

			// Analog inputs
			if (state.analog && Object.keys(state.analog).length > 0) {
				output += 'ANALOG INPUTS:\n';
				for (const [input, value] of Object.entries(state.analog)) {
					if (value !== 0) {
						output += `  ${input}: ${typeof value === 'number' ? value.toFixed(3) : value}\n`;
					}
				}
				output += '\n';
			}

			// IMU data
			if (state.imuSamples && state.imuSamples.length > 0) {
				output += `IMU SAMPLES (${state.imuSamples.length}):\n`;
				state.imuSamples.slice(0, 3).forEach((sample, i) => {
					output += `  [${i}] accel: (${sample.accelX?.toFixed(2)}, ${sample.accelY?.toFixed(2)}, ${sample.accelZ?.toFixed(2)})\n`;
					output += `      gyro:  (${sample.gyroX?.toFixed(2)}, ${sample.gyroY?.toFixed(2)}, ${sample.gyroZ?.toFixed(2)})\n`;
				});
				if (state.imuSamples.length > 3) {
					output += `  ... and ${state.imuSamples.length - 3} more samples\n`;
				}
			}

			return output || 'No active inputs detected';
		}

		// Update channel name display
		channelName.textContent = display.channelName;

		// Make display available globally for debugging
		window.controllerDisplay = display;

		// Initialize button positions after a short delay to ensure image is loaded
		setTimeout(initializeButtonPositions, 100);
	</script>
</body>

</html>